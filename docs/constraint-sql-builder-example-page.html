<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DBCheck SQL Generator</title>
    <style>
        body { font-family: sans-serif; margin: 20px; }
        textarea { width: 100%; height: 200px; margin-bottom: 10px; padding: 10px; border: 1px solid #ccc; }
        button { padding: 10px 20px; background-color: #007bff; color: white; border: none; cursor: pointer; }
        button:hover { background-color: #0056b3; }
        pre { background-color: #f4f4f4; padding: 10px; border: 1px solid #ddd; overflow-x: auto; }
        .container { display: flex; gap: 20px; }
        .input-section, .output-section { flex: 1; }
    </style>
</head>
<body>
<h1>DBCheck SQL Generator</h1>

<p>Incolla qui il tuo file YAML di configurazione o trascinalo nell'area di testo.</p>

<div class="container">
    <div class="input-section">
        <h2>Input YAML</h2>
        <textarea id="yamlInput" placeholder="Incolla qui il tuo YAML o trascina un file YAML..."></textarea>
        <input type="file" id="yamlFile" accept=".yaml, .yml">
        <button onclick="generateSql()">Genera SQL</button>
    </div>
    <div class="output-section">
        <h2>Output SQL</h2>
        <pre id="sqlOutput"></pre>
        <button onclick="downloadSql()" style="display: none;" id="downloadBtn">Scarica SQL</button>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>

<script>
    const yamlInput = document.getElementById('yamlInput');
    const yamlFile = document.getElementById('yamlFile');
    const sqlOutput = document.getElementById('sqlOutput');
    const downloadBtn = document.getElementById('downloadBtn');

    // Funzione per leggere il file YAML trascinato o selezionato
    yamlInput.addEventListener('drop', handleFileDrop, false);
    yamlInput.addEventListener('dragover', handleDragOver, false);
    yamlFile.addEventListener('change', handleFileSelect, false);

    function handleFileSelect(evt) {
        const file = evt.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                yamlInput.value = e.target.result;
            };
            reader.readAsText(file);
        }
    }

    function handleFileDrop(evt) {
        evt.stopPropagation();
        evt.preventDefault();
        const files = evt.dataTransfer.files; // FileList object.
        if (files.length > 0) {
            const file = files[0];
            const reader = new FileReader();
            reader.onload = function(e) {
                yamlInput.value = e.target.result;
            };
            reader.readAsText(file);
        }
    }

    function handleDragOver(evt) {
        evt.stopPropagation();
        evt.preventDefault();
        evt.dataTransfer.dropEffect = 'copy'; // Explicitly show this is a copy.
    }


    function generateSql() {
        const yamlContent = yamlInput.value;
        let generatedSql = '';

        try {
            const config = jsyaml.load(yamlContent); // Parsa il YAML

            if (!config || !config.validation_rules) {
                throw new Error("YAML non valido o manca la sezione 'validation_rules'.");
            }

            config.validation_rules.forEach(rule => {
                let selectClause = `SELECT '${rule.severity}' as SEVERITY,\n`;
                selectClause += `       '${rule.source.table}' as SOURCE_TABLE,\n`;
                selectClause += `       ${rule.source.table}.${rule.source.pk} as SOURCE_TABLE_PK,\n`;

                // Aggiungi SOURCE_TABLE_FIELD e VALUE solo se source.field è definito
                if (rule.source.field) {
                    selectClause += `       '${rule.source.field}' as SOURCE_TABLE_FIELD,\n`;
                    selectClause += `       ${rule.source.table}.${rule.source.field} as SOURCE_TABLE_FIELD_VALUE,\n`;
                } else {
                    selectClause += `       NULL as SOURCE_TABLE_FIELD,\n`; // Ometti o metti NULL
                    selectClause += `       NULL as SOURCE_TABLE_FIELD_VALUE,\n`; // Ometti o metti NULL
                }

                // Prepara il messaggio
                let message = rule.on_fail?.message || rule.on_success?.message || 'No message defined';
                // Semplice interpolazione per "$source.field" e "$source.table"
                message = message.replace(/\$source\.field/g, rule.source.field || 'N/A');
                message = message.replace(/\$source\.table/g, rule.source.table);
                if (rule.check && rule.check.value) {
                     message = message.replace(/\$check\.value/g, rule.check.value);
                }
                if (rule.fk && rule.fk.target) {
                    message = message.replace(/\$fk\.target\.table/g, rule.fk.target.table);
                    message = message.replace(/\$fk\.target\.field/g, rule.fk.target.field || rule.fk.target.pk);
                }
                selectClause += `       '${message}' as MESSAGE`;

                let fromClause = `FROM ${rule.source.table}`;
                let whereClause = '';
                let joinClause = '';

                // Gestione FK
                if (rule.fk) {
                    const targetTable = rule.fk.target.table;
                    const targetPk = rule.fk.target.pk;
                    const targetField = rule.fk.target.field || targetPk; // Usa PK se field non specificato

                    joinClause = `LEFT JOIN ${targetTable} ON ${targetTable}.${targetField} = ${rule.source.table}.${rule.source.field}`;

                    // Per FK semplice, la condizione di WHERE è che la join non trovi match
                    if (!rule.check || !rule.check.sql) { // Se non c'è un check.sql personalizzato nella FK
                        whereClause = `WHERE ${targetTable}.${targetPk} IS NULL`;
                    }
                }

                // Gestione della condizione di check
                if (rule.check) {
                    if (rule.check.operator) {
                        switch (rule.check.operator) {
                            case 'not null':
                                whereClause = `WHERE NOT ( ${rule.source.table}.${rule.source.field} IS NULL )`;
                                // Se on_success è definito per 'not null', la condizione WHERE deve essere l'opposto
                                if (rule.on_success) {
                                    whereClause = `WHERE ${rule.source.table}.${rule.source.field} IS NULL`;
                                }
                                break;
                            case 'is null':
                                whereClause = `WHERE ${rule.source.table}.${rule.source.field} IS NULL`;
                                // Se on_fail è definito per 'is null', la condizione WHERE deve essere l'opposto
                                if (rule.on_fail) {
                                    whereClause = `WHERE NOT ( ${rule.source.table}.${rule.source.field} IS NULL )`;
                                }
                                break;
                            case 'in':
                                whereClause = `WHERE NOT ( ${rule.source.table}.${rule.source.field} IN ${rule.check.value} )`;
                                if (rule.on_success) { // Se on_success, la condizione è IN
                                    whereClause = `WHERE ${rule.source.table}.${rule.source.field} IN ${rule.check.value}`;
                                }
                                break;
                            // Aggiungi altri operatori qui
                            default:
                                console.warn(`Operatore non supportato: ${rule.check.operator}`);
                        }
                    } else if (rule.check.sql) {
                        // Per check.sql, se è on_fail, la WHERE è la negazione (implicitamente o esplicitamente)
                        // Se on_success, la WHERE è la condizione stessa
                        if (rule.on_fail) {
                            whereClause = `WHERE NOT ( ${rule.check.sql} )`;
                        } else { // on_success o free form check
                            whereClause = `WHERE ${rule.check.sql}`;
                        }
                    }
                } else if (rule.check === undefined && rule.fk && rule.on_success) {
                     // Caso FK con on_success senza check.sql esplicito, la condizione è che la join ha avuto successo (contrario di WHERE target.PK IS NULL)
                     const targetTable = rule.fk.target.table;
                     const targetPk = rule.fk.target.pk;
                     whereClause = `WHERE ${targetTable}.${targetPk} IS NOT NULL`;
                }

                // Gestione del FIX
                let fixClause = '';
                const fixSection = rule.on_fail?.fix || rule.on_success?.fix; // Prende fix da on_fail o on_success

                if (fixSection) {
                    if (typeof fixSection === 'string') { // SQL custom per il fix
                        let fixSql = fixSection;
                        // Interpolazione per ${{FIELD_NAME}}
                        fixSql = fixSql.replace(/\$\{\{([A-Z0-9_]+\.[A-Z0-9_]+)\}\}/g, (match, p1) => {
                            // Qui dovresti avere una logica per mappare p1 (es. TABLE1.TABLE1PK)
                            // al campo corrispondente nella SELECT. Per semplicità, usiamo il nome del campo direttamente.
                            // In un sistema reale, dovresti assicurarti che il campo sia accessibile e quotato correttamente.
                            const [tableName, fieldName] = p1.split('.');
                            return `' || ${tableName}.${fieldName} || '`; // Concatenazione per SQL
                        });
                        selectClause += `,\n       '${fixSql}' as FIX`;
                    } else if (fixSection.delete) {
                        selectClause += `,\n       'DELETE FROM ${rule.source.table} WHERE ${rule.source.table}.${rule.source.pk} = ' || ${rule.source.table}.${rule.source.pk} as FIX`;
                    } else if (fixSection.update !== undefined) { // Check se update è presente (anche se vuoto)
                        selectClause += `,\n       'UPDATE ${rule.source.table} SET ${rule.source.field} = "${fixSection.update}" WHERE ${rule.source.table}.${rule.source.pk} = ' || ${rule.source.table}.${rule.source.pk} as FIX`;
                    }
                }


                generatedSql += `-- Rule ID: ${rule.id}\n`;
                generatedSql += `${selectClause}\n`;
                generatedSql += `${fromClause}\n`;
                if (joinClause) generatedSql += `${joinClause}\n`;
                if (whereClause) generatedSql += `${whereClause}\n`;
                generatedSql += `;\n\n`;
            });

            sqlOutput.textContent = generatedSql;
            downloadBtn.style.display = 'inline-block';
        } catch (e) {
            sqlOutput.textContent = `Errore nella generazione SQL:\n${e.message}`;
            console.error(e);
            downloadBtn.style.display = 'none';
        }
    }

    function downloadSql() {
        const filename = 'dbcheck_queries.sql';
        const element = document.createElement('a');
        element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(sqlOutput.textContent));
        element.setAttribute('download', filename);
        element.style.display = 'none';
        document.body.appendChild(element);
        element.click();
        document.body.removeChild(element);
    }
</script>
</body>
</html>